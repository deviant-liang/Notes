#include <pcap.h>
#include <iostream>
#include <cstring>
#include <unistd.h>    // for sleep
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <chrono>
#include <thread>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <pcap file>" << std::endl;
        return 1;
    }

    // Open the pcap file
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_offline(argv[1], errbuf);
    if (!handle) {
        std::cerr << "Couldn't open pcap file: " << errbuf << std::endl;
        return 1;
    }

    struct pcap_pkthdr *header;
    const u_char *packet;
    int res;

    // Open raw socket
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sockfd < 0) {
        perror("socket");
        return 1;
    }

    // Track the time for replay
    struct timeval last_ts = {0, 0};

    while ((res = pcap_next_ex(handle, &header, &packet)) >= 0) {
        if (res == 0) {
            // Timeout occurred, continue to next packet
            continue;
        }

        // Calculate the delay between packets based on timestamp
        if (last_ts.tv_sec != 0) {
            long delay_sec = header->ts.tv_sec - last_ts.tv_sec;
            long delay_usec = header->ts.tv_usec - last_ts.tv_usec;
            if (delay_usec < 0) {
                delay_usec += 1000000;
                delay_sec--;
            }
            std::this_thread::sleep_for(std::chrono::seconds(delay_sec) + std::chrono::microseconds(delay_usec));
        }

        // Send packet through raw socket
        if (sendto(sockfd, packet, header->caplen, 0, nullptr, 0) < 0) {
            perror("sendto");
            break;
        }

        // Update the last timestamp
        last_ts = header->ts;
    }

    // Cleanup
    close(sockfd);
    pcap_close(handle);

    return 0;
}
