#include <pcap.h>
#include <iostream>
#include <cstring>
#include <unistd.h>    // for sleep
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <chrono>
#include <thread>

int main(int argc, char *argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <pcap file> <interval (ms)> <destination IP>" << std::endl;
        return 1;
    }

    // Parse the interval and destination IP
    int interval_ms = std::stoi(argv[2]);
    const char* dest_ip = argv[3];

    // Open the pcap file
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_offline(argv[1], errbuf);
    if (!handle) {
        std::cerr << "Couldn't open pcap file: " << errbuf << std::endl;
        return 1;
    }

    struct pcap_pkthdr *header;
    const u_char *packet;
    int res;

    // Open raw socket
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sockfd < 0) {
        perror("socket");
        return 1;
    }

    // Set up the destination address structure
    struct sockaddr_in dest_addr;
    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(0);  // Port 0 for raw IP packets
    if (inet_pton(AF_INET, dest_ip, &dest_addr.sin_addr) <= 0) {
        std::cerr << "Invalid destination IP address" << std::endl;
        return 1;
    }

    // Track the time for replay
    struct timeval last_ts = {0, 0};

    while ((res = pcap_next_ex(handle, &header, &packet)) >= 0) {
        if (res == 0) {
            // Timeout occurred, continue to next packet
            continue;
        }

        // Sleep for user-defined interval between packets
        std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));

        // Send packet through raw socket to the specified destination
        if (sendto(sockfd, packet, header->caplen, 0, (struct sockaddr*)&dest_addr, sizeof(dest_addr)) < 0) {
            perror("sendto");
            break;
        }
    }

    // Cleanup
    close(sockfd);
    pcap_close(handle);

    return 0;
}