#include <pcap.h>
#include <exanic/exanic.h>
#include <exanic/tx.h>
#include <iostream>
#include <chrono>
#include <thread>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <pcap file> <interval (ms)>" << std::endl;
        return 1;
    }

    // Parse the interval
    int interval_ms = std::stoi(argv[2]);

    // Open the pcap file
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle = pcap_open_offline(argv[1], errbuf);
    if (!handle) {
        std::cerr << "Couldn't open pcap file: " << errbuf << std::endl;
        return 1;
    }

    struct pcap_pkthdr *header;
    const u_char *packet;
    int res;

    // Open Exanic device
    exanic_t *exanic = exanic_acquire_handle("exanic0");
    if (exanic == nullptr) {
        std::cerr << "Failed to acquire Exanic handle" << std::endl;
        return 1;
    }

    // Open the TX (transmit) stream
    exanic_tx_t *tx = exanic_acquire_tx_buffer(exanic, 0);
    if (tx == nullptr) {
        std::cerr << "Failed to acquire Exanic TX buffer" << std::endl;
        exanic_release_handle(exanic);
        return 1;
    }

    // Track the time for replay
    while ((res = pcap_next_ex(handle, &header, &packet)) >= 0) {
        if (res == 0) {
            continue;
        }

        // Sleep for user-defined interval between packets
        std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));

        // Send packet via Exanic
        if (exanic_transmit_frame(tx, packet, header->caplen) < 0) {
            std::cerr << "Failed to send packet" << std::endl;
            break;
        }
    }

    // Cleanup
    exanic_release_tx_buffer(tx);
    exanic_release_handle(exanic);
    pcap_close(handle);

    return 0;
}
